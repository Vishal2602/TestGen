import OpenAI from "openai";

const openai = new OpenAI({ 
  baseURL: "https://api.x.ai/v1", 
  apiKey: process.env.XAI_API_KEY || "" 
});

interface GrokTestGenerationParams {
  functionCode: string;
  functionName: string;
  specification?: string;
  testType: 'whitebox' | 'blackbox' | 'both';
}

interface CoverageMetrics {
  statementCoverage: number;
  branchCoverage: number;
  pathCoverage: number;
  boundaryValuesCovered: number;
  edgeCasesCovered: number;
}

/**
 * Generates test cases using Grok API
 */
export async function generateTestCases({
  functionCode,
  functionName,
  specification,
  testType
}: GrokTestGenerationParams): Promise<{
  testCode: string;
  testCount: number;
  coverage: CoverageMetrics;
}> {
  try {
    // Construct prompt based on test type and available specs
    let prompt = `I need you to generate comprehensive Jest test cases for the following JavaScript/TypeScript function:\n\n`;
    prompt += `\`\`\`\n${functionCode}\n\`\`\`\n\n`;
    
    if (specification) {
      prompt += `Here is the specification for this function:\n\n${specification}\n\n`;
    }
    
    switch (testType) {
      case 'whitebox':
        prompt += `Please generate whitebox tests focusing on statement coverage, branch coverage, and path coverage. Ensure edge cases are tested.`;
        break;
      case 'blackbox':
        prompt += `Please generate blackbox tests using Boundary Value Analysis and Equivalence Class Partitioning. Focus on functionality rather than implementation details.`;
        break;
      case 'both':
      default:
        prompt += `Please generate both whitebox and blackbox tests for comprehensive coverage. Include path coverage and boundary value analysis.`;
        break;
    }
    
    prompt += `\n\nFormat the output as a complete Jest test file with the following structure:
\`\`\`javascript
// Generated by TestGen - Grok Powered Testing Tool

import { ${functionName} } from './${functionName.split('/').pop()}';

describe('${functionName}', () => {
  // Test cases here
  test('should ...', () => {
    // Test implementation
  });
  
  // More test cases...
});
\`\`\`

In addition to generating the code, please provide a coverage analysis in JSON format at the end of your response, like this:

\`\`\`json
{
  "statementCoverage": 90, // percentage of statements covered
  "branchCoverage": 85, // percentage of branches covered
  "pathCoverage": 75, // percentage of paths covered
  "boundaryValuesCovered": 4, // number of boundary values tested
  "edgeCasesCovered": 3 // number of edge cases tested
}
\`\`\`

Make sure to use appropriate Jest assertions (expect) and include comprehensive test cases that verify the function behavior.`;

    // Call Grok API
    const response = await openai.chat.completions.create({
      model: "grok-2-1212", // Use text-only model
      messages: [
        {
          role: "system",
          content: "You are a software testing expert specializing in creating high-quality Jest test cases for JavaScript/TypeScript code."
        },
        {
          role: "user",
          content: prompt
        }
      ],
      temperature: 0.7,
      max_tokens: 3000
    });

    // Extract test code from response
    const generatedText = response.choices[0].message.content || '';
    
    // Extract code block for the test code
    const codeRegex = /```(?:javascript|typescript)?\s*([\s\S]*?)```/;
    const codeMatch = generatedText.match(codeRegex);
    let testCode = codeMatch ? codeMatch[1].trim() : '';
    
    // Extract JSON coverage metrics
    const jsonRegex = /```json\s*([\s\S]*?)```/;
    const jsonMatch = generatedText.match(jsonRegex);
    
    // Default coverage metrics
    let coverage: CoverageMetrics = {
      statementCoverage: 0,
      branchCoverage: 0,
      pathCoverage: 0,
      boundaryValuesCovered: 0,
      edgeCasesCovered: 0
    };
    
    // Parse coverage metrics if found
    if (jsonMatch) {
      try {
        // Remove comments from JSON string
        const jsonStr = jsonMatch[1].replace(/\/\/.*$/gm, '').trim();
        const parsedCoverage = JSON.parse(jsonStr);
        coverage = {
          statementCoverage: parsedCoverage.statementCoverage || 0,
          branchCoverage: parsedCoverage.branchCoverage || 0,
          pathCoverage: parsedCoverage.pathCoverage || 0,
          boundaryValuesCovered: parsedCoverage.boundaryValuesCovered || 0,
          edgeCasesCovered: parsedCoverage.edgeCasesCovered || 0
        };
      } catch (error) {
        console.warn('Error parsing coverage metrics:', error);
      }
    }
    
    // If no test code was found, use full response
    if (!testCode) {
      testCode = generatedText;
    }
    
    // Count test cases
    const testCount = (testCode.match(/test\(/g) || []).length;
    
    return {
      testCode,
      testCount,
      coverage
    };
  } catch (error) {
    console.error('Error calling Grok API:', error);
    throw new Error('Failed to generate test cases with Grok API: ' + 
      (error instanceof Error ? error.message : String(error)));
  }
}
